package service

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"scs/model"

	"github.com/gin-gonic/gin"
	"github.com/lucsky/cuid"
)

// Function to write a struct to a JSON file
func writeJSON(data interface{}) error {
	file, err := os.Create("db.json")
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ") // Pretty print JSON
	return encoder.Encode(data)
}

// Function to read a struct from a JSON file
func readJSON(data interface{}) error {
	file, err := os.Open("db.json")
	if err != nil {
		return err
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	return decoder.Decode(data)
}

// Read all vulnerability types from db
func DoGetGetVulnerabilityTypes() ([]model.VulnerabilityType, error) {
	var vulnerabilityTypes []model.VulnerabilityType
	err := readJSON(&vulnerabilityTypes)
	return vulnerabilityTypes, err
}

// Return all vulnerabilty types or treat error if exists
func GetVulnerabilityTypes(c *gin.Context) {
	vulnerabilityTypes, err := DoGetGetVulnerabilityTypes()
	if err != nil {
		c.IndentedJSON(http.StatusInternalServerError, gin.H{"message": fmt.Sprintf("error reading from db %v", err)})
		return
	}
	c.IndentedJSON(http.StatusOK, vulnerabilityTypes)
}

func GetVulnerabilityTypeByID(c *gin.Context) {
	id := c.Param("id")

	vulnerabilityTypes, err := DoGetGetVulnerabilityTypes()

	if err != nil {
		c.IndentedJSON(http.StatusInternalServerError, gin.H{"message": fmt.Sprintf("error reading from db %v", err)})
		return
	}

	// Loop over the list of types, looking for
	// an type whose ID value matches the parameter.
	for _, t := range vulnerabilityTypes {
		if t.ID == id {
			c.IndentedJSON(http.StatusOK, t)
			return
		}
	}
	c.IndentedJSON(http.StatusNotFound, gin.H{"message": "search type not found"})
}

// postAlbums adds an album from JSON received in the request body.
func PostVulnerabilityType(c *gin.Context) {
	var newType model.VulnerabilityType

	// Call BindJSON to bind the received JSON to
	// newType.
	if err := c.BindJSON(&newType); err != nil {
		c.IndentedJSON(http.StatusInternalServerError, gin.H{"message": fmt.Sprintf("error reading from db %v", err)})
	}

	vulnerabilityTypes, _ := DoGetGetVulnerabilityTypes()

	// Save, just add a new cuid and append it to array
	if newType.ID == "" {
		newType.ID = cuid.New()
		vulnerabilityTypes = append(vulnerabilityTypes, newType)

		// Update, search for the existing type and replace it
	} else {
		index := -1 // Initialize index to -1 (not found)

		// Iterate through the array to find the index
		for i, value := range vulnerabilityTypes {
			if value.ID == newType.ID {
				index = i
				break // Exit the loop once the value is found
			}
		}

		// Replace the existing type
		if index != -1 {
			vulnerabilityTypes[index] = newType
			// Add the new type to the slice.
		} else {
			c.IndentedJSON(http.StatusExpectationFailed, gin.H{"message": fmt.Sprintf("could not find vulnerability type with ID: %q", newType.ID)})
			return
		}
	}

	err := writeJSON(vulnerabilityTypes)
	if err != nil {
		c.IndentedJSON(http.StatusExpectationFailed, gin.H{"message": fmt.Sprintf("error while saving type %v", err)})
		return
	}
	c.IndentedJSON(http.StatusCreated, newType)
}
