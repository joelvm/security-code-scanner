package dao

import (
	"encoding/json"
	"fmt"
	"os"
	"scs/model"

	"github.com/lucsky/cuid"
)

// Function to write a struct to a JSON file
func writeJSON(data interface{}) error {
	file, err := os.Create("db.json")
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ") // Pretty print JSON
	return encoder.Encode(data)
}

// Function to read a struct from a JSON file
func readJSON(data interface{}) error {
	file, err := os.Open("db.json")
	if err != nil {
		return err
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	return decoder.Decode(data)
}

// Read all vulnerability types from db
func GetVulnerabilityTypes() ([]model.VulnerabilityType, error) {
	var vulnerabilityTypes []model.VulnerabilityType
	err := readJSON(&vulnerabilityTypes)
	return vulnerabilityTypes, err
}

// GET a vulnerability types by id
func GetVulnerabilityTypeById(id string) (*model.VulnerabilityType, error) {
	vulnerabilityTypes, err := GetVulnerabilityTypes()

	if err != nil {
		return nil, err
	}

	// Loop over the list of types, looking for
	// an type whose ID value matches the parameter.
	for _, t := range vulnerabilityTypes {
		if t.ID == id {
			return &t, err
		}
	}

	return nil, fmt.Errorf("can't find vulnerability type with id: %s", id)
}

func DeleteVulnerabilityTypeByID(id string) (bool, error) {
	vulnerabilityTypes, err := GetVulnerabilityTypes()

	if err != nil {
		return false, err
	}

	filtered := []model.VulnerabilityType{}
	// Loop over the list of types, looking for
	// an type whose ID value matches the parameter.
	for _, t := range vulnerabilityTypes {
		if t.ID != id {
			filtered = append(filtered, t)
		}
	}

	err = writeJSON(filtered)
	if err != nil {
		return false, err
	}
	return true, err
}

func SaveVulnerabilityType(newType model.VulnerabilityType) (*model.VulnerabilityType, error) {

	vulnerabilityTypes, _ := GetVulnerabilityTypes()

	// Save, just add a new cuid and append it to array
	if newType.ID == "" {
		newType.ID = cuid.New()
		vulnerabilityTypes = append(vulnerabilityTypes, newType)

		// Update, search for the existing type and replace it
	} else {
		index := -1 // Initialize index to -1 (not found)

		// Iterate through the array to find the index
		for i, value := range vulnerabilityTypes {
			if value.ID == newType.ID {
				index = i
				break // Exit the loop once the value is found
			}
		}

		// Replace the existing type
		if index != -1 {
			vulnerabilityTypes[index] = newType
			// Add the new type to the slice.
		} else {
			return nil, fmt.Errorf("could not find vulnerability type with ID: %q", newType.ID)
		}
	}

	err := writeJSON(vulnerabilityTypes)
	if err != nil {
		return nil, fmt.Errorf("error while saving type %v", err)
	}
	return &newType, nil
}
